name: Build, Test and Deploy

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

env:
  AWS_REGION: eu-central-1
  AWS_ACCOUNT_ID: 824912998004
  ECR_REPOSITORY: picus-flask-app
  ECS_SERVICE: picus-flask-service
  ECS_CLUSTER: picus-cluster
  ECS_TASK_DEFINITION: picus-task-definition
  CONTAINER_NAME: picus-flask-app

jobs:
  test:
    name: Test Application
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Check Python availability
      run: |
        python3 --version || echo "Python3 not found"
        which python3 || echo "python3 not in PATH"
    
    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: "3.10"
    
    - name: Verify Python installation
      run: |
        python --version
        which python
    
    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        echo "Installing requirements..."
        pip install -r requirements.txt || echo "Failed to install requirements"
        echo "Installing pytest..."
        pip install pytest pytest-cov || echo "Failed to install pytest"
        echo "Verifying installations..."
        pip list | grep -E "(Flask|boto3|gunicorn|pytest)"
    
    - name: Run tests
      run: |
        echo "Running tests..."
        echo "Python version: $(python --version)"
        echo "Working directory: $(pwd)"
        echo "Files in directory:"
        ls -la
        echo "Running test_app.py..."
        python test_app.py
      env:
        DYNAMODB_TABLE_NAME: picus_data
        AWS_DEFAULT_REGION: eu-central-1

  build-and-deploy:
    name: Build Docker Image and Deploy
    needs: test
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v2
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}
    
    - name: Login to Amazon ECR
      id: login-ecr
      uses: aws-actions/amazon-ecr-login@v1
    
    - name: Build, tag, and push image to Amazon ECR
      id: build-image
      env:
        ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        IMAGE_TAG: ${{ github.sha }}
      run: |
        # Build Docker image (GitHub Actions runner is already linux/amd64)
        docker build -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG .
        docker tag $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG $ECR_REGISTRY/$ECR_REPOSITORY:latest
        # Push image to ECR
        docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
        docker push $ECR_REGISTRY/$ECR_REPOSITORY:latest
        echo "image=$ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG" >> $GITHUB_OUTPUT
    
    - name: Fill in the new image ID in the Amazon ECS task definition
      id: task-def
      uses: aws-actions/amazon-ecs-render-task-definition@v1
      with:
        task-definition: ecs-task-definition.json
        container-name: ${{ env.CONTAINER_NAME }}
        image: ${{ env.AWS_ACCOUNT_ID }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com/${{ env.ECR_REPOSITORY }}:latest
    
    - name: Deploy Amazon ECS task definition
      uses: aws-actions/amazon-ecs-deploy-task-definition@v1
      with:
        task-definition: ${{ steps.task-def.outputs.task-definition }}
        service: ${{ env.ECS_SERVICE }}
        cluster: ${{ env.ECS_CLUSTER }}
        wait-for-service-stability: true
        wait-for-minutes: 10

  deploy-lambda:
    name: Deploy Lambda Function
    needs: test
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v2
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}
    
    - name: Install Python dependencies for Lambda
      run: |
        pip install boto3 -t .
    
    - name: Create Lambda deployment package
      run: |
        zip -r lambda-function.zip handler.py boto3* botocore* -x "*.pyc" -x "*__pycache__*"
    
    - name: Create or get Lambda IAM role
      id: lambda-role
      run: |
        ROLE_NAME="picus-lambda-role"
        
        # Check if role exists
        if aws iam get-role --role-name $ROLE_NAME --region ${{ env.AWS_REGION }} 2>/dev/null; then
          echo "Role exists, getting ARN..."
          ROLE_ARN=$(aws iam get-role --role-name $ROLE_NAME --query 'Role.Arn' --output text --region ${{ env.AWS_REGION }})
        else
          echo "Creating IAM role for Lambda..."
          
          # Create trust policy
          cat > lambda-trust-policy.json << 'EOF'
        {
          "Version": "2012-10-17",
          "Statement": [
            {
              "Effect": "Allow",
              "Principal": {
                "Service": "lambda.amazonaws.com"
              },
              "Action": "sts:AssumeRole"
            }
          ]
        }
        EOF
          
          # Create role
          aws iam create-role \
            --role-name $ROLE_NAME \
            --assume-role-policy-document file://lambda-trust-policy.json \
            --region ${{ env.AWS_REGION }}
          
          # Attach basic Lambda execution policy
          aws iam attach-role-policy \
            --role-name $ROLE_NAME \
            --policy-arn arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole \
            --region ${{ env.AWS_REGION }}
          
          # Create and attach DynamoDB policy
          cat > lambda-dynamodb-policy.json << EOF
        {
          "Version": "2012-10-17",
          "Statement": [
            {
              "Effect": "Allow",
              "Action": [
                "dynamodb:DeleteItem",
                "dynamodb:GetItem"
              ],
              "Resource": "arn:aws:dynamodb:${{ env.AWS_REGION }}:${{ env.AWS_ACCOUNT_ID }}:table/picus_data"
            }
          ]
        }
        EOF
          
          aws iam put-role-policy \
            --role-name $ROLE_NAME \
            --policy-name DynamoDBAccess \
            --policy-document file://lambda-dynamodb-policy.json \
            --region ${{ env.AWS_REGION }}
          
          ROLE_ARN=$(aws iam get-role --role-name $ROLE_NAME --query 'Role.Arn' --output text --region ${{ env.AWS_REGION }})
          
          echo "‚è≥ Waiting for role to be ready..."
          sleep 10
        fi
        
        echo "role_arn=$ROLE_ARN" >> $GITHUB_OUTPUT
        echo "‚úÖ Using role: $ROLE_ARN"
    
    - name: Deploy Lambda function with AWS CLI
      run: |
        FUNCTION_NAME="picus-delete-function"
        ROLE_ARN="${{ steps.lambda-role.outputs.role_arn }}"
        MAX_RETRIES=5
        RETRY_DELAY=10
        
        # Function'ƒ±n update durumunu kontrol et ve bekle
        wait_for_function_ready() {
          local retries=0
          while [ $retries -lt $MAX_RETRIES ]; do
            STATUS=$(aws lambda get-function \
              --function-name $FUNCTION_NAME \
              --region ${{ env.AWS_REGION }} \
              --query 'Configuration.LastUpdateStatus' \
              --output text 2>/dev/null || echo "NOT_FOUND")
            
            if [ "$STATUS" == "Successful" ] || [ "$STATUS" == "NOT_FOUND" ]; then
              echo "‚úÖ Function is ready (Status: $STATUS)"
              return 0
            elif [ "$STATUS" == "InProgress" ]; then
              echo "‚è≥ Function update in progress, waiting... (Status: $STATUS)"
              sleep $RETRY_DELAY
              retries=$((retries + 1))
            else
              echo "‚ö†Ô∏è  Function status: $STATUS, waiting..."
              sleep $RETRY_DELAY
              retries=$((retries + 1))
            fi
          done
          echo "‚ùå Function not ready after $MAX_RETRIES retries"
          return 1
        }
        
        # Check if function exists
        if aws lambda get-function --function-name $FUNCTION_NAME --region ${{ env.AWS_REGION }} 2>/dev/null; then
          echo "üìù Updating existing function..."
          
          # Function'ƒ±n hazƒ±r olmasƒ±nƒ± bekle
          wait_for_function_ready
          
          # Update function code
          echo "üì¶ Updating function code..."
          aws lambda update-function-code \
            --function-name $FUNCTION_NAME \
            --zip-file fileb://lambda-function.zip \
            --region ${{ env.AWS_REGION }}
          
          # Code update'in tamamlanmasƒ±nƒ± bekle
          wait_for_function_ready
          
          # Update environment variables
          echo "‚öôÔ∏è  Updating function configuration..."
          aws lambda update-function-configuration \
            --function-name $FUNCTION_NAME \
            --environment "Variables={DYNAMODB_TABLE_NAME=picus_data}" \
            --region ${{ env.AWS_REGION }} || echo "‚ö†Ô∏è  Configuration update may have failed, but continuing..."
          
          echo "‚úÖ Lambda function updated successfully!"
        else
          echo "üÜï Creating new Lambda function..."
          aws lambda create-function \
            --function-name $FUNCTION_NAME \
            --runtime python3.10 \
            --role $ROLE_ARN \
            --handler handler.delete_item \
            --zip-file fileb://lambda-function.zip \
            --timeout 30 \
            --memory-size 256 \
            --environment "Variables={DYNAMODB_TABLE_NAME=picus_data}" \
            --architecture x86_64 \
            --region ${{ env.AWS_REGION }}
          
          echo "‚úÖ Lambda function created successfully!"
        fi
    
    - name: Create API Gateway (if needed)
      run: |
        FUNCTION_NAME="picus-delete-function"
        
        # Check if API Gateway already exists (this is a simplified check)
        # In production, you might want to use a more robust method
        echo "‚ÑπÔ∏è  API Gateway configuration can be done via AWS Console or Terraform"
        echo "Function URL can be created with:"
        echo "  aws lambda create-function-url-config --function-name $FUNCTION_NAME --auth-type NONE"

